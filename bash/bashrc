# Directory of this script
DIR=$(dirname "$BASH_SOURCE")

################################################################################
# Determine if to use colors
################################################################################
__use_colors () {
    case "$TERM" in
        xterm-color) printf "yes";;
        xterm-256color) printf "yes";;
        *) printf "no";;
    esac
}
__os_name () {
    uname -o 2> /dev/null || printf "Unknown"
}
if [ "$(__use_colors)" = yes ]; then
    # Support .dircolors file in home
    if command -v dircolors &> /dev/null; then
        test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    fi
fi
################################################################################

################################################################################
# Tab completion
################################################################################
# System provided completions
if [ -f /etc/profile.d/bash_completion.sh ]; then
    source /etc/profile.d/bash_completion.sh
elif [ -f /usr/local/share/bash-completion/bash_completion.sh ]; then
    source /usr/local/share/bash-completion/bash_completion.sh
fi
################################################################################

################################################################################
# Prompt
################################################################################
# Notes on colors:
#   \e = \033 (also works in printf, etc)
#   \[ = \001 (ONLY works in PS1)
#   \] = \002 (ONLY works in PS1)
#   colors format: \e[00;31m
#   end color: \e[00m
#   however, in prompt must contain inside \[ \] to allow readline to determine
#   how long the prompt is. In PS1 this is done usie \[ and \] but in 
#   printf, etc have to use \001 and \002
__prompt_git_label () {
    local colors=$(__use_colors)
    local git_branch="$(git rev-parse --abbrev-ref HEAD)"
    local git_dirty=""
    if [ ! -z "$git_branch" ]; then
        git_dirty="$([[ -z $(git status --porcelain 2> /dev/null) ]] || printf " ✗")"
        if [ $colors = yes ]; then
            printf "(\001\e[01;36m\002${git_branch}\001\e[00m\002\001\e[01;31m\002${git_dirty}\001\e[00m\002)"
        else
            printf "(${git_branch}${git_dirty})"
        fi
    fi
}

__prompt_arrow () {
    local lasterr=$?
    local colors=$(__use_colors)
    local arrow="→"
    if [ $colors = yes ] && [ $lasterr -ne 0 ]; then
        arrow="\001\e[01;31m\002${arrow}\001\e[00m\002"
    elif [ $colors = yes ]; then
        arrow="\001\e[01;32m\002${arrow}\001\e[00m\002"
    fi
    printf "$arrow"
}

if [ "$(__use_colors)" = yes ]; then
    PS1="${debian_chroot:+($debian_chroot)}\$(__prompt_arrow)[\[\e[01;32m\]\u@\h\[\e[00m\]:\[\e[01;34m\]\W\[\e[00m\]]\$(__prompt_git_label)\$ "
else
    PS1="${debian_chroot:+($debian_chroot)}\$(__prompt_arrow)[\u@\h:\W]\$(__prompt_git_label)\$ "
fi

if type "wslpath" > /dev/null 2>&1; then
    # Required for duplicate tab in windows terminal
    PROMPT_COMMAND=${PROMPT_COMMAND:+"$PROMPT_COMMAND; "}'printf "\e]9;9;%s\e\\" "$(wslpath -w "$PWD")"'
fi
################################################################################


################################################################################
# Default Aliases / Functions
################################################################################
# Color settings for commands
if [ "$(__use_colors)" = yes ]; then
    alias ls='ls --color=auto'
    alias la='ls -A --color=auto'
    alias ll='ls -alF --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
else
    alias ls='ls --color=never'
    alias la='ls -A --color=never'
    alias ll='ls -alF --color=never'
    alias grep='grep --color=never'
    alias fgrep='fgrep --color=never'
    alias egrep='egrep --color=never'
fi



# open function like macos
case "$(__os_name)" in
    "Darwin")
        # Not needed b/c already exists on macos
    ;;
    *)
        if type "wslpath" > /dev/null 2>&1; then
            # Linux via WSL
            openwin(){
                target=$(wslpath -w "$1")
                cmd.exe /c start "" "$target" > /dev/null 2>&1
            }
        fi
        # Linux, FreeBSD, etc
        open(){
            nohup xdg-open "$*" > /dev/null 2>&1
        }
    ;;
esac
################################################################################
